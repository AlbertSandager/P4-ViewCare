----------------------------------------------------------------------------------
-- Company: 
-- Engineer: 
-- 
-- Create Date:    21:14:14 03/21/2014 
-- Design Name: 
-- Module Name:    i2s_top - Behavioral 
-- Project Name: 
-- Target Devices: 
-- Tool versions: 
-- Description: 
--
-- Dependencies: 
--
-- Revision: 
-- Revision 0.01 - File Created
-- Additional Comments: 
--
----------------------------------------------------------------------------------
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.STD_LOGIC_SIGNED.ALL;
use IEEE.NUMERIC_STD.ALL;

-- Uncomment the following library declaration if using
-- arithmetic functions with Signed or Unsigned values
--use IEEE.NUMERIC_STD.ALL;

-- Uncomment the following library declaration if instantiating
-- any Xilinx primitives in this code.
--library UNISIM;
--use UNISIM.VComponents.all;

entity i2s is
    Port (
					CLK 				: in  STD_LOGIC;
					RST				: in  STD_LOGIC;
					I2S_DATA_I 		: in  STD_LOGIC;
					I2S_LRCK_I 		: in  STD_LOGIC;
					I2S_BCK_I 		: in  STD_LOGIC;
					I2S_DATA_O 		: out STD_LOGIC;
					I2S_LRCK_O 		: out STD_LOGIC;
					I2S_BCK_O 		: out STD_LOGIC;
					CTRL				: in  STD_LOGIC;
					IND				: out STD_LOGIC_VECTOR(3 downto 0);
					Volume			: in  STD_LOGIC_VECTOR(6 downto 0)
		    );
end i2s;

architecture Behavioral of i2s is

component fifo_generator_v9_3
	PORT (
					rst 				: IN  STD_LOGIC;
					wr_clk 			: IN  STD_LOGIC;
					rd_clk 			: IN  STD_LOGIC;
					din 				: IN  STD_LOGIC_VECTOR(31 DOWNTO 0);
					wr_en 			: IN  STD_LOGIC;
					rd_en 			: IN  STD_LOGIC;
					dout 				: OUT STD_LOGIC_VECTOR(31 DOWNTO 0);
					full 				: OUT STD_LOGIC;
					empty 			: OUT STD_LOGIC;
					prog_full 		: OUT STD_LOGIC
			);
end component;

component filter
    Port (
					CLKLeft 			: in  STD_LOGIC;
					CLKRight 		: in  STD_LOGIC;
					InLeft 			: in  STD_LOGIC_VECTOR (23 downto 0);
					InRIght 			: in  STD_LOGIC_VECTOR (23 downto 0);
					OutLeft 			: out STD_LOGIC_VECTOR (23 downto 0);
					OutRight 		: out STD_LOGIC_VECTOR (23 downto 0);
					CTL 				: in  STD_LOGIC
			);
end component;

component volume_control
    Port (
					LeftIn 			: in  STD_LOGIC_VECTOR (23 downto 0);
					RightIn 			: in  STD_LOGIC_VECTOR (23 downto 0);
					LeftOut 			: out STD_LOGIC_VECTOR (23 downto 0);
					RightOut 		: out STD_LOGIC_VECTOR (23 downto 0);
					volume 			: in  STD_LOGIC_VECTOR (6 downto 0)
			 );
end component;

signal LeftSample 				: STD_LOGIC_VECTOR (31 downto 0) := "00000000000000000000000000000000";
signal RightSample 				: STD_LOGIC_VECTOR (31 downto 0) := "00000000000000000000000000000000";
signal LeftOut		 				: STD_LOGIC_VECTOR (31 downto 0) := "00000000000000000000000000000000";
signal RightOut 					: STD_LOGIC_VECTOR (31 downto 0) := "00000000000000000000000000000000";

type TClkDivider is range 1 downto 0;		--3 = 48KHz (1:1), 1 = 96KHz (2:1)
signal clkDivider					: TClkDivider := 0;

signal bitCount					: natural range 31 downto 0 := 0;
signal sendClk						: STD_LOGIC := '0';
signal LRCKOut						: STD_LOGIC := '0';

signal FifoOutLeftSample 		: STD_LOGIC_VECTOR (31 downto 0) := "00000000000000000000000000000000";
signal FifoOutRightSample 		: STD_LOGIC_VECTOR (31 downto 0) := "00000000000000000000000000000000";
signal fifoLeftWR_EN				: STD_LOGIC := '0';
signal fifoRightWR_EN			: STD_LOGIC := '0';
signal fifoLeftRD_EN				: STD_LOGIC := '0';
signal fifoRightRD_EN			: STD_LOGIC := '0';
signal emptyLeft					: STD_LOGIC;
signal emptyRight					: STD_LOGIC;
signal halfFullLeft				: STD_LOGIC;
signal halfFullRight				: STD_LOGIC;

signal leftEnable					: STD_LOGIC := '0';	--wait for halb-full fifo
signal rightEnable				: STD_LOGIC := '0';	--wait for halb-full fifo

signal FifoWrClk					: STD_LOGIC;

type I2SState is (channelRunning, dataStrobe, dataReady);

signal leftChannelState 		: I2SState := dataReady;
signal rightChannelState		: I2SState := dataReady;
signal leftChannelOutState		: I2SState := dataReady;
signal rightChannelOutState	: I2SState := dataReady;

type TResetCnt is range (12000) downto 0;				--500ms reset time, needs I2S signal
signal resetCnt					: TResetCnt := 0;
signal RESET						: STD_LOGIC := '1';

signal upSampleCntL				: natural range 1 downto 0 := 0;
signal upSampleCntR				: natural range 1 downto 0 := 0;

signal filterLeftClk 			: STD_LOGIC := '0';
signal filterRightClk 			: STD_LOGIC := '0';

signal FilterInLeft		 		: STD_LOGIC_VECTOR (23 downto 0) := "000000000000000000000000";
signal FilterInRight		 		: STD_LOGIC_VECTOR (23 downto 0) := "000000000000000000000000";
signal FilterOutLeft		 		: STD_LOGIC_VECTOR (23 downto 0) := "000000000000000000000000";
signal FilterOutRight		 	: STD_LOGIC_VECTOR (23 downto 0) := "000000000000000000000000";
signal FinalOutLeft		 		: STD_LOGIC_VECTOR (23 downto 0) := "000000000000000000000000";
signal FinalOutRight		 		: STD_LOGIC_VECTOR (23 downto 0) := "000000000000000000000000";

begin

FIFOLeft: fifo_generator_v9_3 port map (
		rst 				=> RESET,
		wr_clk 			=> FifoWrClk,
		rd_clk 			=> sendClk,
		din 				=> LeftSample,
		wr_en 			=> fifoLeftWR_EN,
		rd_en 			=> fifoLeftRD_EN,
		dout 				=> FifoOutLeftSample,
		full 				=> IND(1),
		empty 			=> emptyLeft,
		prog_full 		=> halfFullLeft
  );
  
FIFORight: fifo_generator_v9_3 port map (
		rst 				=> RESET,
		wr_clk 			=> FifoWrClk,
		rd_clk 			=> sendClk,
		din 				=> RightSample,
		wr_en 			=> fifoRightWR_EN,
		rd_en 			=> fifoRightRD_EN,
		dout 				=> FifoOutRightSample,
		full 				=> IND(3),
		empty 			=> emptyRight,
		prog_full 		=> halfFullRight
  );

AudioFilter: filter port map (
		CLKLeft 			=> filterLeftClk,
		CLKRight 		=> filterRightClk,
      InLeft 			=> FilterInLeft,
      InRIght 			=> FilterInRight,
      OutLeft 			=> FilterOutLeft,
      OutRight 		=> FilterOutRIght,
      CTL 				=> CTRL
  );

VolumeCtrl: volume_control port map (
		LeftIn 			=> FilterOutLeft,
		RightIn 			=> FilterOutRight,
		LeftOut 			=> FinalOutLeft,
		RightOut 		=> FinalOutRight,
		volume 			=> Volume
  );

I2S_SAMPLE: process (I2S_BCK_I, RST, I2S_LRCK_I) begin

	if(I2S_BCK_I'event and I2S_BCK_I = '1') then
		
		if (RST = '1') then
			resetCnt <= 0;
			RESET		<= '1';
		else
			if (resetCnt < TResetCnt'high) and (I2S_LRCK_I = '0') then
				resetCnt <= resetCnt + 1;
				RESET		<= '1';
			end if;
			if (resetCnt = TResetCnt'high) then
				RESET		<= '0';
			end if;
		end if;
		
		if (leftChannelState = channelRunning) then
			LeftSample  <= LeftSample(30 downto 0) & I2S_DATA_I;
		end if;
		
		if (rightChannelState = channelRunning) then
			RightSample  <= RightSample(30 downto 0) & I2S_DATA_I;
		end if;
		
	end if;
end process;

I2S_INPUT: process (I2S_BCK_I, I2S_LRCK_I, RESET) begin
	
	if(I2S_BCK_I'event and I2S_BCK_I = '1') then
		
		if (RESET = '0') then
		
		case leftChannelState is
			when channelRunning =>
				if (I2S_LRCK_I = '1') then
					leftChannelState <= dataStrobe;
				else
					leftChannelState <= channelRunning;
				end if;
				fifoLeftWR_EN <= '0';
			when dataStrobe =>
				leftChannelState <= dataReady;
				fifoLeftWR_EN <= '1';
			when dataReady =>
				if (I2S_LRCK_I = '0') then
					leftChannelState <= channelRunning;
				else
					leftChannelState <= dataReady;
				end if;
				fifoLeftWR_EN <= '0';
		end case;
				
		case rightChannelState is
			when channelRunning =>
				if (I2S_LRCK_I = '0') then
					rightChannelState <= dataStrobe;
				else
					rightChannelState <= channelRunning;
				end if;
				fifoRightWR_EN <= '0';
			when dataStrobe =>
				rightChannelState <= dataReady;
				fifoRightWR_EN <= '1';
			when dataReady =>
				if (I2S_LRCK_I = '1') then
					rightChannelState <= channelRunning;
				else
					rightChannelState <= dataReady;
				end if;
				fifoRightWR_EN <= '0';
		end case;
			
		else
			fifoLeftWR_EN  <= '0';
			fifoRightWR_EN <= '0';
			leftChannelState <= dataReady;
			rightChannelState <= dataReady;
		end if;
		
	end if;
	
end process;

I2S_EXT_DIVIDE: process (CLK) begin

	if(CLK'event and CLK = '1') then
	
		if (clkDivider = TClkDivider'high) then
			clkDivider <= 0;
			sendClk	<= not sendClk;
		else
			clkDivider	<= clkDivider + 1;
		end if;
		
	end if;
	
end process;
	
I2S_LRCK: process (sendClk, RESET) begin

	if(sendClk'event and sendClk = '0') then
	
		if (RESET = '0') then
		
		if (bitCount = 31) then
			bitCount <= 0;
			LRCKOut	<= not LRCKOut;
		else
			bitCount	<= bitCount + 1;
		end if;
		
		else
			bitCount <= 0;
			LRCKOut  <= '0';
		end if;
		
	end if;
	
end process;
	
I2S_SEND: process (sendClk, LRCKOut, RESET) begin
	
	if(sendClk'event and sendClk = '0') then
		
	if (RESET = '0') then
	
	if (halfFullLeft = '1') then
		leftEnable <= '1';
--	elsif (emptyLeft = '1') then
--		leftEnable <= '0';
	end if;
	
	if (halfFullRight = '1') then
		rightEnable <= '1';
--	elsif (emptyRight = '1') then
--		rightEnable <= '0';
	end if;
	
	case leftChannelOutState is
			when channelRunning =>
				filterLeftClk <= '0';
				if (LRCKOut = '1') then
					leftChannelOutState <= dataStrobe;
					
					upSampleCntL <= upSampleCntL + 1;
											
					if (leftEnable = '1') and (upSampleCntL < 1) then
						fifoLeftRD_EN <= '1';
					end if;
					FilterInLeft <= FifoOutLeftSample(31 downto 8);
					
					if (upSampleCntL = 1) then
						upSampleCntL <= 0;
						--LeftOut <= FifoOutLeftSample;
						FilterInLeft <= FifoOutLeftSample(31 downto 8);
					end if;
					
				else
					leftChannelOutState <= channelRunning;
					I2S_DATA_O <= LeftOut(31);
					LeftOut  <= LeftOut(30 downto 0) & '0';
					fifoLeftRD_EN <= '0';
				end if;
			when dataStrobe =>
				leftChannelOutState <= dataReady;
				fifoLeftRD_EN <= '0';
				filterLeftClk <= '1';
				LeftOut <= FinalOutLeft & "00000000";
			when dataReady =>
				if (LRCKOut = '0') then
					leftChannelOutState <= channelRunning;
					I2S_DATA_O <= LeftOut(31);
					LeftOut  <= LeftOut(30 downto 0) & '0';
				else
					leftChannelOutState <= dataReady;
				end if;
				fifoLeftRD_EN <= '0';
				filterLeftClk <= '0';
		end case;

		case rightChannelOutState is
			when channelRunning =>
				filterRightClk <= '0';
				if (LRCKOut = '0') then
					rightChannelOutState <= dataStrobe;
					
					upSampleCntR <= upSampleCntR + 1;
					
					if (rightEnable = '1') and (upSampleCntR < 1) then
						fifoRightRD_EN <= '1';
					end if;
					FilterInRight <= FifoOutRightSample(31 downto 8);
						
					if (upSampleCntR = 1) then
						upSampleCntR <= 0;
						FilterInRight <= FifoOutRightSample(31 downto 8);
					end if;
					
				else
					rightChannelOutState <= channelRunning;
					fifoRightRD_EN <= '0';
					I2S_DATA_O <= RightOut(31);
					RightOut <= RightOut(30 downto 0) & '0';
				end if;
			when dataStrobe =>
				rightChannelOutState <= dataReady;
				fifoRightRD_EN <= '0';
				filterRightClk <= '1';
				RightOut <= FinalOutRight & "00000000";
			when dataReady =>
				if (LRCKOut = '1') then
					rightChannelOutState <= channelRunning;
					I2S_DATA_O <= RightOut(31);
					RightOut <= RightOut(30 downto 0) & '0';
				else
					rightChannelOutState <= dataReady;
				end if;
				fifoRightRD_EN <= '0';
				filterRightClk <= '0';
		end case;
		
		else
			leftChannelOutState	<= dataReady;
			rightChannelOutState	<= dataReady;
			upSampleCntL <= 0;
			upSampleCntR <= 0;
			fifoLeftRD_EN  <= '0';
			fifoRightRD_EN <= '0';
			filterLeftClk <= '0';
			filterRightClk <= '0';
			leftEnable <= '0';
			rightEnable <= '0';
		end if;
	end if;
	
end process;

--testing: use BCK_I as BCK_OUT, disable DIVIDE process
--sendClk <= I2S_BCK_I;

I2S_BCK_O 	<= sendClk when RESET = '0' else '0';
I2S_LRCK_O 	<= LRCKOut when RESET = '0' else '0';

-- testing, shortcut
--I2S_BCK_O 	<= I2S_BCK_I;
--I2S_LRCK_O 	<= I2S_LRCK_I;
--I2S_DATA_O  <= I2S_DATA_I;
-- end testing

FifoWrClk	<= not I2S_BCK_I;

IND(0) <= emptyLeft;
IND(2) <= emptyRight;

end Behavioral;

